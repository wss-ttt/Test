<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button type="button" id="btn1">确定1</button>
    <button type="button" id="btn2">确定2</button>
</body>
<script src="core.js"></script>
<script>
    // 添加静态方法 
    $.extend({
        // 注册事件
        addEvent: function (target, type, fn) {
            // 对参数进行判断
            // target必须是DOM
            // type 必须是字符串
            // fn必须是函数
            if (!target.nodeType || !jQuery.isString(type) || !jQuery.isFunction(fn)) {
                return;
            }
            if (target.addEventListener) {
                target.addEventListener(type, fn);
            } else {
                target.attachEvent('on' + type, fn);
            }
        },
        // 解绑事件
        removeEvent: function (target, type, fn) {
            // 对参数进行判断
            // target必须是DOM
            // type 必须是字符串
            // fn必须是函数
            if (!target.nodeType || !jQuery.isString(type) || !jQuery.isFunction(fn)) {
                return;
            }
            if (target.removeEventListener) {
                target.removeEventListener(type, fn);
            } else {
                target.detachEvent('on' + type, fn);
            }
        }
    });

    // 添加实例方法
    $.fn.extend({
        on: function (type, fn) {
            /*
            实现思路:
                1.遍历所有的元素
                2.判断每一个元素有没有$_event_cache这个属性值
                3.如果有,则继续使用,没有则初始化一个对象
                4.在继续判断这个对象有没有对应的事件类型的数组
                5.如果没有,说明是第一次绑定
                    5-1.那么需要给$_event_cache这个对象以type为key添加一个数组
                    5-2.然后把传入的回到函数fn,push进去
                    5-3.最后还得绑定对应的事件(调用静态的addEvaent方法)
                    5-4.这个事件回调里面去遍历事件类型数组,并依次执行
                    5-5.执行时,需要改变内部的this,还需要把事件对象传递出去
                6.如果有,直接把传入的回调函数push到对应事件的数组里面去就可以了
                7.return this
            */
            // 1.
            this.each(function () {
                var self = this; // 保存每一个元素
                // 2.3步骤
                this.$_event_cache = this.$_event_cache || {};
                // 4.步骤
                if (!this.$_event_cache[type]) {
                    // 5-1.步骤
                    this.$_event_cache[type] = [];
                    // 5-2.步骤
                    this.$_event_cache[type].push(fn);
                    // 5-3.步骤 
                    // 要明白:事件回调函数执行的时机是在事件被触发的时候才会执行
                    jQuery.addEvent(self, type, function (e) {
                        // 5-4.步骤
                        for (var i = 0, len = self.$_event_cache[type].length; i < len; i++) {
                            // 5-5.步骤  ->1.需要改变this的指向,2.传递事件对象
                            self.$_event_cache[type][i].call(self, e);
                        }
                    })
                } else {
                    // 6.步骤
                    // tips:这个时候就不要再绑定事件了,只需要数组中push fn就行了
                    this.$_event_cache[type].push(fn);
                }
            })
            return this;
        },
        off: function (type, fn) {
        }
    });
    function fn1(e) {
        console.log('1', this, e);
    }
    function fn2(e) {
        console.log('2', this, e);
    }

    $('button').on('click', fn1);
    $('button').on('click', fn2);

</script>

</html>