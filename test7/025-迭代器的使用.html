<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        ul,
        li {
            list-style: none;
        }

        .box {
            width: 400px;
            height: 400px;
            margin: 100px auto;
            background-color: aliceblue;
            overflow: hidden;
            position: relative;
            /*父级*/
        }

        ul.inner {
            width: 500%;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }

        ul.inner li {
            width: 20%;
            height: 100%;
            float: left;
        }
    </style>
</head>

<body>
    <div class="box">
        <ul class="inner" id="container">
            <li>01</li>
            <li>02</li>
            <li>03</li>
            <li>04</li>
        </ul>
    </div>
    <script>
        var Iterator = function (items, container) {
            // 获取父容器
            var container = container && document.getElementById(container)
                || document,
                // 获取元素
                items = container.getElementsByTagName(items),
                // 获取元素长度(个数)
                length = items.length,
                // 当前索引值,默认为 0
                index = 0;
            // 缓存原生数组的splice方法
            var splice = [].splice;
            return {
                // 获取第一个元素
                first: function () {
                    // 校正当前索引值
                    index = 0;
                    // 返回元素
                    return items[index];
                },
                // 获取最后一个元素
                last: function () {
                    // 校正当前索引值
                    index = length - 1;
                    return items[index];
                },
                // 获取前一个元素
                pre: function () {
                    /**
                     * 需要判断这个元素是否是第一个元素,
                     * 如果是的话,则返回空元素,并设置索引 index = 0
                     * 
                    */
                    if (--index > 0) {
                        return items[index];
                    } else {
                        index = 0;
                        return null;
                    }
                },
                // 获取后一个元素
                next: function () {
                    /**
                     *需要判断这个元素是否是最后一个元素 
                     * 如果是的话,则返回空元素,并设置索引值 index = length - 1
                    */
                    if (++index < length) {
                        return items[index];
                    } else {
                        index = length - 1;
                        return null;
                    }

                },
                // 获取某一个元素
                get: function (num) {
                    /**
                     * 如果num>0,正向获取,
                     * 否则,逆向获取
                     * 技巧: 使用了 % 运算符
                    */
                    index = num > 0 ? num % length : num % length + length;
                    return items[index];
                },
                // 对每一个元素执行某一个方法
                dealEach: function (fn) {
                    // 第二个参数开始为回调函数中的参数
                    // 此时args已经是Array了,是一个数组了
                    var args = splice.call(arguments, 1);
                    // 遍历元素
                    for (var i = 0; i < length; i++) {
                        // fn.apply(items[i], args);
                        // 修改如下
                        fn.call(items[i], items[i], i, args);
                    }
                },
                // 对某一个元素执行某一个方法
                dealItem: function (num, fn) {
                    /**
                     * 1.第三者参数开始为回调函数中的参数
                     * 2.通过this.get方法设置index索引值
                    */
                    fn.apply(this.get(num), splice.call(arguments, 2));
                },
                // 排他方式处理某一个元素
                exclusive: function (num, allFn, numFn) {
                    // 对所有元素执行回调函数
                    this.dealEach(allFn);
                    // 如果num为数组
                    if (({}).toString.call(num) === '[object Array]') {
                        // 遍历数组
                        for (var i = 0, len = num.length; i < len; i++) {
                            // 分别处理数组中的每一个元素
                            this.dealItem(num[i], numFn);
                        }
                    } else {
                        // 处理第num个元素
                        this.dealItem(num, numFn);
                    }
                }
            }
        }
        function animate(ele, attr, fn) {
            //先清定时器
            clearInterval(ele.timer);
            ele.timer = setInterval(function () {
                var flag = true;
                // 遍历attr
                for (var k in attr) {
                    // k -> 属性
                    // attr[k] -> target
                    // 四步
                    var leader;
                    if (k === 'opacity') {
                        // FF chrome ie(含)9+ 获取的透明度值是小数制的
                        // eg 0.3... 所以这里需要乘以100
                        // 在这里进行一个四舍五入 取整
                        // ie8中测试的时候,发现 leader=为一个无限不循环的小数了
                        // 否则就不能停止掉定时器
                        leader = Math.round(getStyle(ele, k) * 100) || 1;
                        console.log(leader);
                    } else {
                        leader = parseInt(getStyle(ele, k)) || 0;
                    }
                    //  求出剩余距离
                    // var distance = attr[k] - leader;
                    //1.获取步长
                    var step = (attr[k] - leader) / 10;
                    //2.二次加工步长
                    step = step > 0 ? Math.ceil(step) : Math.floor(step);
                    leader = leader + step;
                    //3.赋值
                    if (k === 'opacity') {
                        ele.style[k] = leader / 100;   // 小数制
                        // 兼容ie6/7/8 
                        ele.style.filter = 'alpha(opacity=' + leader + ')'; // 百分制
                    } else if (k === 'zIndex') {
                        // 层级的处理,直接赋值就行了,不需要缓动赋值
                        ele.style.zIndex = attr[k];
                    } else {
                        ele.style[k] = leader + "px";
                    }
                    console.log(1);
                    // 或者如下进行判断更加简单(不考虑目标值是小数,eg:400.5)
                    // 而且本身 step就进行取整了,小数值目标也达不到
                    //  4.判断条件:两个值不相等,就说明该属性还没达到目标值,
                    // 那么,此时就不能清除定时器
                    if (attr[k] !== leader) {
                        flag = false;
                    }
                }
                // 5.清除定时器
                if (flag) {
                    clearInterval(ele.timer);
                    // 需要判断是否传递了fn
                    if (fn) {
                        fn();
                    }
                }
            }, 25);
        }
        function getStyle(obj, attr) {
            if (window.getComputedStyle) {
                // ie9 获取  谷歌(因为ie9有该属性)
                return getComputedStyle(obj, null)[attr];
            } else {
                // ie8(含)以下
                return obj.currentStyle[attr];
            }
        }
    </script>
    <script>
        var ul = document.getElementById('container');
        var liIterator = new Iterator('li', 'container');
        var colors = ['red', 'green', 'yellow', '#1acd7e'];

        // 处理每一个元素
        liIterator.dealEach(function (ele, index) {

            ele.style.backgroundColor = colors[index];

        });// 同时也能传递自定义数据

        function slide(items, container) {
            // 获取父容器
            var container = container && document.getElementById(container)
                || document,
                // 获取元素
                items = container.getElementsByTagName(items),
                // 单个item的高度
                itemHeight = items[0].offsetHeight,
                // 单个item的宽度
                itemWidth = items[0].offsetWidth,
                // 获取元素长度(个数)
                // length = items.length,
                // 当前索引值,默认为 0
                index = 0;
            var newItem = items[0].cloneNode(true);
            container.appendChild(newItem);
            var length = items.length;
            console.log(items, length);
            console.log(itemWidth, itemHeight);
            return {
                // 向上滚动
                scrollUp: function () {

                },
                // 向左滚动
                scrollLeft: function () {
                    index++;
                    if (index > length - 1) {// 5 5-1=4
                        container.style.left = 0;
                        index = 1;
                    }
                    animate(container, {
                        left: -itemWidth * index
                    })
                },
                // 向右滚动
                scrollRight: function () {
                },
                // 向下滚动
                scrollBottom: function () { },
            }
        }

        var s = new slide('li', 'container');
        // s.scrollRight();
        var tiemr = setInterval(s.scrollLeft, 3000);
    </script>
</body>

</html>